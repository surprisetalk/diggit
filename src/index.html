<!doctype html>
<html lang="en">
  <head>
    <title>DIGGIT</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark" />
    <link href="/style.css" rel="stylesheet" />
    <script src="https://unpkg.com/@isomorphic-git/lightning-fs"></script>
    <script src="https://unpkg.com/isomorphic-git"></script>
    <script src="/index.js"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import http from "https://unpkg.com/isomorphic-git/http/web/index.js";
      window.fs = new LightningFS("fs");
      window.pfs = window.fs.promises;
      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {
            claudeAuth: localStorage.getItem("claudeAuth"),
            claudeModel: localStorage.getItem("claudeModel") || "sonnet41",
            timezone: -new Date().getTimezoneOffset(),
          },
        });

        app.ports.saveToLocalStorage.subscribe(({ key, value }) => {
          localStorage.setItem(key, value);
        });

        app.ports.saveGithubData.subscribe(({ repo, data }) => {
          const key = `github_${repo}`;
          const storage = JSON.parse(localStorage.getItem(key) || "{}");
          for (const i in data) {
            if (!storage[i]) storage[i] = {};
            for (const j in data[i]) storage[i][j] = data[i][j];
          }
          localStorage.setItem(key, JSON.stringify(storage));
          window.dispatchEvent(
            new CustomEvent("githubDataChanged", {
              detail: { repo, data: storage },
            }),
          );
        });

        window.addEventListener("storage", (event) => {
          if (event.key && event.key.startsWith("github_")) {
            const repo = event.key.replace("github_", "");
            const data = JSON.parse(event.newValue || "{}");
            app.ports.githubDataChanged.send({ repo, data });
          }
        });
        window.addEventListener("githubDataChanged", (event) => {
          app.ports.githubDataChanged.send(event.detail);
        });

        const loadExistingGithubData = () => {
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith("github_")) {
              const repo = key.replace("github_", "");
              const data = JSON.parse(localStorage.getItem(key) || "{}");
              app.ports.githubDataChanged.send({ repo, data });
            }
          }
        };

        loadExistingGithubData();

        let cache = {};
        let loadInterval;

        app.ports.requestRepo.subscribe(async (repoUrl) => {
          if (!repoUrl) return;
          const loading = (progress) =>
            app.ports.progressReported.send({
              message: `Cloning ${repoUrl}...`,
              progress,
            });

          try {
            const dir = `/repos/${repoUrl}`;
            const url = `https://github.com/${repoUrl}`;
            const gitOpts = { cache, fs: window.fs, dir };

            loading(0.1);
            let n = 0;
            loadInterval = setInterval(
              () => loading(Math.min(0.7, (0.1 + ++n * 0.001) / 0.7)),
              100,
            );

            // TODO: Do a fast clone and then a slow clone in background.
            await git.clone({
              ...gitOpts,
              http,
              corsProxy: "https://cors.isomorphic-git.org",
              url,
              since: new Date(0),
              singleBranch: false,
              noCheckout: true,
              nonBlocking: true,
              onMessage: console.log,
              onProgress: (event) =>
                event.phase &&
                event.loaded &&
                event.total &&
                app.ports.progressReported.send({
                  message: `${repoUrl}: ${event.phase}`,
                  progress: event.loaded / event.total,
                }),
            });

            await git.fastForward({
              ...gitOpts,
              http,
              corsProxy: "https://cors.isomorphic-git.org",
              url,
              nonBlocking: true,
              onMessage: console.log,
              onProgress: (event) =>
                event.phase &&
                event.loaded &&
                event.total &&
                app.ports.progressReported.send({
                  message: `${repoUrl}: ${event.phase}`,
                  progress: event.loaded / event.total,
                }),
            });

            clearInterval(loadInterval);
            loading(0.7);
            const commits = await git.log(gitOpts);

            const authors = {};
            const commitData = {};

            for (const commit of commits) {
              const { author, message, parent } = commit.commit;
              const authorId = author.email;
              if (!authors[authorId])
                authors[authorId] = {
                  id: authorId,
                  name: author.name,
                  email: author.email,
                  avatarUrl: null,
                };

              const changedFiles = [];
              const fileExtensions = new Set();
              const directories = new Set();

              try {
                const parentOid = parent && parent[0];
                if (parentOid) {
                  const commitDiff = await git.walk({
                    ...gitOpts,
                    trees: [
                      git.TREE({ ref: parentOid }),
                      git.TREE({ ref: commit.oid }),
                    ],
                    map: async function (filepath, [A, B]) {
                      if (
                        filepath === "." ||
                        (await A?.type()) === "tree" ||
                        (await B?.type()) === "tree"
                      )
                        return;
                      const Aoid = await A?.oid();
                      const Boid = await B?.oid();
                      const type =
                        Aoid === undefined
                          ? "add"
                          : Boid === undefined
                            ? "remove"
                            : Aoid !== Boid
                              ? "modify"
                              : "equal";
                      if (type !== "equal") {
                        const ext = filepath.match(/\.([^.]+)$/);
                        if (ext) fileExtensions.add(`.${ext[1]}`);
                        const dirPath = filepath.substring(
                          0,
                          filepath.lastIndexOf("/"),
                        );
                        if (dirPath) directories.add(`/${dirPath}`);
                        return { path: `/${filepath}`, type };
                      }
                      return null;
                    },
                  });
                  changedFiles.push(
                    ...(await Promise.all(commitDiff)).filter(Boolean),
                  );
                } else {
                  const commitDiff = await git.walk({
                    ...gitOpts,
                    trees: [git.TREE({ ref: commit.oid })],
                    map: async function (filepath, [tree]) {
                      if (!tree || (await tree.type()) === "tree") return null;
                      const ext = filepath.match(/\.([^.]+)$/);
                      if (ext) fileExtensions.add(`.${ext[1]}`);
                      const dirPath = filepath.substring(
                        0,
                        filepath.lastIndexOf("/"),
                      );
                      if (dirPath) directories.add(`/${dirPath}`);
                      return { path: `/${filepath}`, type: "add" };
                    },
                  });
                  changedFiles.push(
                    ...(await Promise.all(commitDiff)).filter(Boolean),
                  );
                }
              } catch (error) {
                console.warn(
                  `Could not get files for commit ${commit.oid}:`,
                  error,
                );
              }

              const hashtags = message.match(/#\w+/g) || [];
              const commitDate = new Date(author.timestamp * 1000);
              const year = commitDate.getFullYear();
              const isMerge = parent && parent.length > 1;

              commitData[commit.oid] = {
                id: commit.oid,
                url: `${url}/commit/${commit.oid}`,
                start: author.timestamp * 1000,
                end: null,
                insertions: 0,
                deletions: 0,
                tags: [
                  "commit",
                  `@${author.name}`,
                  `${year}`,
                  ...(isMerge ? ["merge"] : []),
                  ...Array.from(fileExtensions),
                  ...Array.from(directories).slice(0, 100),
                  ...hashtags,
                ],
                summary: message,
              };
            }

            loading(0.8);
            // Get both local and remote branches
            const localBranches = await git.listBranches(gitOpts);
            const remoteBranches = await git.listBranches({
              ...gitOpts,
              remote: "origin",
            });

            // Combine and deduplicate branches (remote branches come as 'origin/branch')
            const allBranches = new Set(localBranches);
            for (const remoteBranch of remoteBranches) {
              allBranches.add(`origin/${remoteBranch}`);
            }
            const branches = Array.from(allBranches);

            const commitToBranches = {};
            const branchTimeRanges = {};

            // Identify default branch (main, master, or trunk)
            const defaultBranches = ["main", "master", "trunk"];
            let defaultBranch = null;
            for (const branch of branches) {
              const branchName = branch.replace("origin/", "");
              if (defaultBranches.includes(branchName)) {
                defaultBranch = branch;
                break;
              }
            }

            // Get commits from default branch
            const defaultCommits = new Set();
            if (defaultBranch) {
              const defaultBranchCommits = await git.log({
                ...gitOpts,
                ref: defaultBranch,
              });
              for (const commit of defaultBranchCommits) {
                defaultCommits.add(commit.oid);
              }
            }

            for (const branch of branches) {
              const branchCommits = await git.log({ ...gitOpts, ref: branch });

              // Track earliest and latest commit times for this branch
              let earliestTime = null;
              let latestTime = null;
              let divergenceTime = null;

              for (const commit of branchCommits) {
                if (!commitToBranches[commit.oid])
                  commitToBranches[commit.oid] = [];
                commitToBranches[commit.oid].push(branch);

                const commitTime = commit.commit.author.timestamp * 1000;

                // For non-default branches, find the divergence point
                if (branch !== defaultBranch && defaultBranch) {
                  // If this commit is not in the default branch, it's part of the divergence
                  if (!defaultCommits.has(commit.oid)) {
                    if (!divergenceTime || commitTime < divergenceTime) {
                      divergenceTime = commitTime;
                    }
                  }
                }

                if (!earliestTime || commitTime < earliestTime) {
                  earliestTime = commitTime;
                }
                if (!latestTime || commitTime > latestTime) {
                  latestTime = commitTime;
                }
              }

              // Use divergence time if available, otherwise use earliest time
              const startTime = divergenceTime || earliestTime;

              branchTimeRanges[branch] = {
                start: startTime,
                end: latestTime === startTime ? null : latestTime,
              };
            }

            const branchData = {};
            for (const branch of branches) {
              const branchCommit = await git.resolveRef({
                ...gitOpts,
                ref: branch,
              });
              // Clean up branch name for display (remove 'origin/' prefix for remote branches)
              const displayName = branch.replace("origin/", "");
              const timeRange = branchTimeRanges[branch] || {
                start: Date.now(),
                end: null,
              };
              branchData[branch] = {
                id: branchCommit,
                url: `${url}/tree/${displayName}`,
                start: timeRange.start,
                end: timeRange.end,
                insertions: 0,
                deletions: 0,
                tags: ["branch", `>${displayName}`],
                summary: `Branch: ${displayName}`,
              };
            }

            const tags = await git.listTags(gitOpts);
            const commitToTags = {};
            for (const tag of tags) {
              try {
                const tagRef = await git.resolveRef({ ...gitOpts, ref: tag });
                if (!commitToTags[tagRef]) commitToTags[tagRef] = [];
                commitToTags[tagRef].push(tag);
              } catch (error) {
                console.warn(`Could not resolve tag ${tag}:`, error);
              }
            }

            for (const [commitId, branchList] of Object.entries(
              commitToBranches,
            )) {
              if (commitData[commitId])
                commitData[commitId].tags.push(
                  ...branchList.map(
                    (branch) => `>${branch.replace("origin/", "")}`,
                  ),
                );
            }
            for (const [commitId, tagList] of Object.entries(commitToTags)) {
              if (commitData[commitId])
                commitData[commitId].tags.push(
                  ...tagList.map((tag) => `v:${tag}`),
                );
            }

            loading(0.9);
            const getFileList = async (dir, path = "") => {
              const files = [];
              try {
                const entries = await window.pfs.readdir(dir + path);
                for (const entry of entries) {
                  const fullPath = path + "/" + entry;
                  const stat = await window.pfs.stat(dir + fullPath);
                  files.push(
                    ...(stat.isDirectory()
                      ? await getFileList(dir, fullPath)
                      : [fullPath.substring(1)]),
                  );
                }
              } catch (error) {
                console.warn(`Could not read directory ${dir + path}:`, error);
              }
              return files;
            };
            const files = await getFileList(dir);

            app.ports.repoLoaded.send({
              url,
              commits: commitData,
              authors,
              tags: {},
              branches: branchData,
              files,
              github: JSON.parse(
                localStorage.getItem(`github_https://github.com/${repoUrl}`) ||
                  "{}",
              ),
              report: null,
            });
          } catch (error) {
            console.error("Failed to clone repository:", error);
            app.ports.pageErrored.send(
              error?.message ?? "Failed to clone repository",
            );
          } finally {
            clearInterval(loadInterval);
            loading(1.0);
          }
        });
      } catch (error) {
        console.error(error);
        app.ports.pageErrored.send(error?.message ?? "Something went wrong.");
      }
    </script>
  </body>
</html>
