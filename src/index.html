<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark" />
    <link href="/style.css" rel="stylesheet" />
    <script src="https://unpkg.com/@isomorphic-git/lightning-fs"></script>
    <script src="https://unpkg.com/isomorphic-git"></script>
    <script src="/index.js"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import http from "https://unpkg.com/isomorphic-git/http/web/index.js";
      window.fs = new LightningFS("fs");
      window.pfs = window.fs.promises;
      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {
            claudeAuth: localStorage.getItem("claudeAuth"),
            claudeModel: localStorage.getItem("claudeModel") || "sonnet41",
            timezone: -new Date().getTimezoneOffset(),
          },
        });

        let cache = {};
        let loadInterval;

        app.ports.requestRepo.subscribe(async (repoUrl) => {
          if (!repoUrl) return;
          const loading = (progress) =>
            app.ports.progressReported.send({
              message: `Cloning ${repoUrl}...`,
              progress,
            });

          try {
            const dir = `/repos/${repoUrl}`;
            const url = `https://github.com/${repoUrl}`;
            const gitOpts = { cache, fs: window.fs, dir };

            loading(0.1);
            let n = 0;
            loadInterval = setInterval(
              () => loading(Math.min(0.7, (0.1 + ++n * 0.0005) / 0.7)),
              100,
            );

            await git.clone({
              ...gitOpts,
              http,
              corsProxy: "https://cors.isomorphic-git.org",
              url,
              since: new Date(0),
              singleBranch: false,
              noCheckout: false,
              onMessage: console.log,
              onProgress: (event) =>
                event.phase &&
                event.loaded &&
                event.total &&
                app.ports.progressReported.send({
                  message: `${repoUrl}: ${event.phase}`,
                  progress: event.loaded / event.total,
                }),
            });

            clearInterval(loadInterval);
            loading(0.7);
            const commits = await git.log(gitOpts);

            const authors = {};
            const commitData = {};

            for (const commit of commits) {
              const { author, message, parent } = commit.commit;
              const authorId = author.email;
              if (!authors[authorId])
                authors[authorId] = {
                  id: authorId,
                  name: author.name,
                  email: author.email,
                  avatarUrl: null,
                };

              const changedFiles = [];
              const fileExtensions = new Set();
              const directories = new Set();

              try {
                const parentOid = parent && parent[0];
                if (parentOid) {
                  const commitDiff = await git.walk({
                    ...gitOpts,
                    trees: [
                      git.TREE({ ref: parentOid }),
                      git.TREE({ ref: commit.oid }),
                    ],
                    map: async function (filepath, [A, B]) {
                      if (
                        filepath === "." ||
                        (await A?.type()) === "tree" ||
                        (await B?.type()) === "tree"
                      )
                        return;
                      const Aoid = await A?.oid();
                      const Boid = await B?.oid();
                      const type =
                        Aoid === undefined
                          ? "add"
                          : Boid === undefined
                            ? "remove"
                            : Aoid !== Boid
                              ? "modify"
                              : "equal";
                      if (type !== "equal") {
                        const ext = filepath.match(/\.([^.]+)$/);
                        if (ext) fileExtensions.add(`.${ext[1]}`);
                        const dirPath = filepath.substring(
                          0,
                          filepath.lastIndexOf("/"),
                        );
                        if (dirPath) directories.add(`/${dirPath}`);
                        return { path: `/${filepath}`, type };
                      }
                      return null;
                    },
                  });
                  changedFiles.push(
                    ...(await Promise.all(commitDiff)).filter(Boolean),
                  );
                } else {
                  const commitDiff = await git.walk({
                    ...gitOpts,
                    trees: [git.TREE({ ref: commit.oid })],
                    map: async function (filepath, [tree]) {
                      if (!tree || (await tree.type()) === "tree") return null;
                      const ext = filepath.match(/\.([^.]+)$/);
                      if (ext) fileExtensions.add(`.${ext[1]}`);
                      const dirPath = filepath.substring(
                        0,
                        filepath.lastIndexOf("/"),
                      );
                      if (dirPath) directories.add(`/${dirPath}`);
                      return { path: `/${filepath}`, type: "add" };
                    },
                  });
                  changedFiles.push(
                    ...(await Promise.all(commitDiff)).filter(Boolean),
                  );
                }
              } catch (error) {
                console.warn(
                  `Could not get files for commit ${commit.oid}:`,
                  error,
                );
              }

              const hashtags = message.match(/#\w+/g) || [];
              const commitDate = new Date(author.timestamp * 1000);
              const year = commitDate.getFullYear();
              const isMerge = parent && parent.length > 1;

              commitData[commit.oid] = {
                id: commit.oid,
                url: `${url}/commit/${commit.oid}`,
                start: author.timestamp * 1000,
                end: null,
                insertions: 0,
                deletions: 0,
                tags: [
                  "commit",
                  `@${author.name}`,
                  `${year}`,
                  ...(isMerge ? ["merge"] : []),
                  ...Array.from(fileExtensions),
                  ...Array.from(directories).slice(0, 100),
                  ...hashtags,
                ],
                summary: message,
              };
            }

            loading(0.8);
            const branches = await git.listBranches(gitOpts);

            const commitToBranches = {};
            for (const branch of branches) {
              const branchCommits = await git.log({ ...gitOpts, ref: branch });
              for (const commit of branchCommits) {
                if (!commitToBranches[commit.oid])
                  commitToBranches[commit.oid] = [];
                commitToBranches[commit.oid].push(branch);
              }
            }

            const branchData = {};
            for (const branch of branches) {
              const branchCommit = await git.resolveRef({
                ...gitOpts,
                ref: branch,
              });
              branchData[branch] = {
                id: branchCommit,
                url: `${url}/tree/${branch}`,
                start: Date.now(), // TODO: This is wrong.
                end: null,
                insertions: 0,
                deletions: 0,
                tags: ["branch", `>${branch}`],
                summary: `Branch: ${branch}`,
              };
            }

            const tags = await git.listTags(gitOpts);
            const commitToTags = {};
            for (const tag of tags) {
              try {
                const tagRef = await git.resolveRef({ ...gitOpts, ref: tag });
                if (!commitToTags[tagRef]) commitToTags[tagRef] = [];
                commitToTags[tagRef].push(tag);
              } catch (error) {
                console.warn(`Could not resolve tag ${tag}:`, error);
              }
            }

            for (const [commitId, branchList] of Object.entries(
              commitToBranches,
            )) {
              if (commitData[commitId])
                commitData[commitId].tags.push(
                  ...branchList.map((branch) => `>${branch}`),
                );
            }
            for (const [commitId, tagList] of Object.entries(commitToTags)) {
              if (commitData[commitId])
                commitData[commitId].tags.push(
                  ...tagList.map((tag) => `v:${tag}`),
                );
            }

            loading(0.9);
            const getFileList = async (dir, path = "") => {
              const files = [];
              try {
                const entries = await window.pfs.readdir(dir + path);
                for (const entry of entries) {
                  const fullPath = path + "/" + entry;
                  const stat = await window.pfs.stat(dir + fullPath);
                  files.push(
                    ...(stat.isDirectory()
                      ? await getFileList(dir, fullPath)
                      : [fullPath.substring(1)]),
                  );
                }
              } catch (error) {
                console.warn(`Could not read directory ${dir + path}:`, error);
              }
              return files;
            };
            const files = await getFileList(dir);

            app.ports.repoLoaded.send({
              url,
              commits: commitData,
              authors,
              tags: {},
              branches: branchData,
              files,
              github: { issues: {}, events: {}, users: {} },
              report: null,
            });
          } catch (error) {
            console.error("Failed to clone repository:", error);
            app.ports.pageErrored.send(
              error?.message ?? "Failed to clone repository",
            );
          } finally {
            clearInterval(loadInterval);
            loading(1.0);
          }
        });
      } catch (error) {
        console.error(error);
        app.ports.pageErrored.send(error?.message ?? "Something went wrong.");
      }
    </script>
  </body>
</html>
