<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark" />
    <link href="/style.css" rel="stylesheet" />
    <script src="https://unpkg.com/@isomorphic-git/lightning-fs"></script>
    <script src="https://unpkg.com/isomorphic-git"></script>
    <script src="/index.js"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import http from "https://unpkg.com/isomorphic-git/http/web/index.js";
      window.fs = new LightningFS("fs");
      window.pfs = window.fs.promises;
      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {
            claudeAuth: localStorage.getItem("claudeAuth"),
            claudeModel: localStorage.getItem("claudeModel") || "sonnet41",
          },
        });

        let cache = {};
        let loadInterval;

        app.ports.requestRepo.subscribe(async (repoUrl) => {
          if (!repoUrl) return;
          const loading = (progress) =>
            // TODO: Is this working?
            app.ports.progressReported.send({
              message: `Cloning ${repoUrl}...`,
              progress,
            });

          try {
            const dir = `/repos/${repoUrl}`;
            const url = `https://github.com/${repoUrl}`;

            loading(0.1);

            let n = 0;
            loadInterval = setInterval(
              () => loading(Math.min(0.7, (0.1 + ++n * 0.0005) / 0.7)),
              100,
            );

            await git.clone({
              cache,
              fs: window.fs,
              http, // TODO: Track progress?
              dir,
              corsProxy: "https://cors.isomorphic-git.org",
              url,
              since: new Date(0),
              singleBranch: false,
              noCheckout: false,
              onMessage: console.log,
              onProgress: (event) =>
                event.phase &&
                event.loaded &&
                event.total &&
                app.ports.progressReported.send({
                  message: `${repoUrl}: ${event.phase}`,
                  progress: event.loaded / event.total,
                }),
            });

            clearInterval(loadInterval);

            loading(0.7);

            const commits = await git.log({
              cache,
              fs: window.fs,
              dir,
            });

            const authors = {};
            const commitData = {};

            for (const commit of commits) {
              const authorId = commit.commit.author.email;

              if (!authors[authorId])
                authors[authorId] = {
                  id: authorId,
                  name: commit.commit.author.name,
                  email: commit.commit.author.email,
                  avatarUrl: null,
                };

              // Get the files changed in this commit
              const changedFiles = [];
              const fileExtensions = new Set();
              const directories = new Set();

              try {
                // Get parent commit for comparison
                const parentOid =
                  commit.commit.parent && commit.commit.parent[0];
                if (parentOid) {
                  const commitDiff = await git.walk({
                    cache,
                    fs: window.fs,
                    dir,
                    trees: [
                      git.TREE({ ref: parentOid }),
                      git.TREE({ ref: commit.oid }),
                    ],
                    map: async function (filepath, [A, B]) {
                      // ignore directories
                      if (filepath === ".") return;
                      if (
                        (await A?.type()) === "tree" ||
                        (await B?.type()) === "tree"
                      )
                        return;

                      // generate ids
                      const Aoid = await A?.oid();
                      const Boid = await B?.oid();

                      // determine modification type
                      let type = "equal";
                      if (Aoid !== Boid) type = "modify";
                      if (Aoid === undefined) type = "add";
                      if (Boid === undefined) type = "remove";

                      // Only track changed files
                      if (type !== "equal") {
                        // Track file extensions
                        const ext = filepath.match(/\.([^.]+)$/);
                        if (ext) fileExtensions.add(`.${ext[1]}`);

                        // Track directories
                        const dirPath = filepath.substring(
                          0,
                          filepath.lastIndexOf("/"),
                        );
                        if (dirPath) directories.add(`/${dirPath}`);

                        return {
                          path: `/${filepath}`,
                          type: type,
                        };
                      }
                      return null;
                    },
                  });
                  changedFiles.push(
                    ...(await Promise.all(commitDiff)).filter(Boolean),
                  );
                } else {
                  // For initial commit, list all files as added
                  const commitDiff = await git.walk({
                    cache,
                    fs: window.fs,
                    dir,
                    trees: [git.TREE({ ref: commit.oid })],
                    map: async function (filepath, [tree]) {
                      if (!tree || (await tree.type()) === "tree") return null;

                      // Track file extensions
                      const ext = filepath.match(/\.([^.]+)$/);
                      if (ext) fileExtensions.add(`.${ext[1]}`);

                      // Track directories
                      const dirPath = filepath.substring(
                        0,
                        filepath.lastIndexOf("/"),
                      );
                      if (dirPath) directories.add(`/${dirPath}`);

                      return {
                        path: `/${filepath}`,
                        type: "add",
                      };
                    },
                  });
                  changedFiles.push(
                    ...(await Promise.all(commitDiff)).filter(Boolean),
                  );
                }
              } catch (error) {
                console.warn(
                  `Could not get files for commit ${commit.oid}:`,
                  error,
                );
              }

              // Extract hashtags from commit message
              const hashtags = commit.commit.message.match(/#\w+/g) || [];

              // Date/time tags
              const commitDate = new Date(
                commit.commit.author.timestamp * 1000,
              );
              const year = commitDate.getFullYear();
              const month = commitDate
                .toLocaleString("en-US", { month: "short" })
                .toLowerCase();

              // Check if merge commit (has more than one parent)
              const isMerge =
                commit.commit.parent && commit.commit.parent.length > 1;

              commitData[commit.oid] = {
                id: commit.oid,
                url: `${url}/commit/${commit.oid}`,
                start: commit.commit.author.timestamp * 1000,
                end: null,
                insertions: 0,
                deletions: 0,
                tags: [
                  "commit",
                  `@${commit.commit.author.name}`,
                  `${year}`,
                  // `${year}-${month}`,
                  ...(isMerge ? ["merge"] : []),
                  ...Array.from(fileExtensions),
                  ...Array.from(directories).slice(0, 100), // Limit to 100 directories
                  ...hashtags,
                ],
                summary: commit.commit.message,
              };
            }

            loading(0.8);

            const branches = await git.listBranches({
              cache,
              fs: window.fs,
              dir,
            });

            // Track which commits belong to which branches
            const commitToBranches = {};
            for (const branch of branches) {
              const branchCommits = await git.log({
                cache,
                fs: window.fs,
                dir,
                ref: branch,
              });
              for (const commit of branchCommits) {
                if (!commitToBranches[commit.oid]) {
                  commitToBranches[commit.oid] = [];
                }
                commitToBranches[commit.oid].push(branch);
              }
            }

            const branchData = {};
            for (const branch of branches) {
              const branchCommit = await git.resolveRef({
                cache,
                fs: window.fs,
                dir,
                ref: branch,
              });
              branchData[branch] = {
                id: branchCommit,
                url: `${url}/tree/${branch}`,
                start: Date.now(), // TODO:
                end: null,
                insertions: 0,
                deletions: 0,
                tags: ["branch", `>${branch}`], // TODO: Add other tags, e.g. >branch, .ext, /dir, #tag, @author
                summary: `Branch: ${branch}`,
              };
            }

            // Get git tags
            const tags = await git.listTags({
              cache,
              fs: window.fs,
              dir,
            });

            // Map tags to commits
            const commitToTags = {};
            for (const tag of tags) {
              try {
                const tagRef = await git.resolveRef({
                  cache,
                  fs: window.fs,
                  dir,
                  ref: tag,
                });
                if (!commitToTags[tagRef]) {
                  commitToTags[tagRef] = [];
                }
                commitToTags[tagRef].push(tag);
              } catch (error) {
                console.warn(`Could not resolve tag ${tag}:`, error);
              }
            }

            // Add branch tags to commits
            for (const [commitId, branchList] of Object.entries(
              commitToBranches,
            )) {
              if (commitData[commitId]) {
                const branchTags = branchList.map((branch) => `>${branch}`);
                commitData[commitId].tags.push(...branchTags);
              }
            }

            // Add git tags to commits
            for (const [commitId, tagList] of Object.entries(commitToTags)) {
              if (commitData[commitId]) {
                const versionTags = tagList.map((tag) => `v:${tag}`);
                commitData[commitId].tags.push(...versionTags);
              }
            }

            loading(0.9);

            // TODO: Inline this.
            async function getFileList(dir, path = "") {
              const files = [];
              try {
                const entries = await window.pfs.readdir(dir + path);
                for (const entry of entries) {
                  const fullPath = path + "/" + entry;
                  const stat = await window.pfs.stat(dir + fullPath);
                  if (stat.isDirectory()) {
                    const subFiles = await getFileList(dir, fullPath);
                    files.push(...subFiles);
                  } else {
                    files.push(fullPath.substring(1));
                  }
                }
              } catch (error) {
                console.warn(`Could not read directory ${dir + path}:`, error);
              }
              return files;
            }
            const files = await getFileList(dir);

            app.ports.repoLoaded.send({
              url: url,
              commits: commitData,
              authors: authors,
              tags: {},
              branches: branchData,
              files: files,
              github: {
                issues: {},
                events: {},
                users: {},
              },
              report: null,
            });
          } catch (error) {
            console.error("Failed to clone repository:", error);
            app.ports.pageErrored.send(
              error?.message ?? "Failed to clone repository",
            );
          } finally {
            clearInterval(loadInterval);
            loading(1.0);
          }
        });
      } catch (error) {
        console.error(error);
        app.ports.pageErrored.send(error?.message ?? "Something went wrong.");
      }
    </script>
  </body>
</html>
